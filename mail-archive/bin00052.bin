<!doctype linuxdoc system>
<!-- 

************************** begin comment *****************************
Il seguente è l'HOW-TO per programmare in PHP.
Questo documento è in formato SGML. 
Si deve utilizzare il pacchetto sgml per processare questo documento
************************* end of comment *****************************

-->
<!--
************************** SGML USER GUIDE *****************************
La guida utente SGML su linux è collocata in /usr/doc/sgml-tools
Leggete i documenti example.sgml e guide.html.
Usage:
	HTML	  	sgml2html foo  (Non dare estensione .sgml qui!!)
	Text	 	sgml2txt foo.sgml
	Latex	  	sgml2latex foo.sgml
	Postscript 	sgml2latex -language=english -o ps foo.sgml
	DVI  		sgml2latex -d foo.sgml
	Lyx			sgml2lyx foo.sgml
	Richtext 	sgml2rtf foo.sgml
	gnuinfo  	sgml2info foo.sgml
	man			sgml2txt -man foo.sgml
	SGML	 	sgmlcheck foo.sgml
************************* end of comment *******************************
-->

<article opts="italian">

<!-- Informazione sui titoli -->

<title>PHP HOW-TO
<!-- chapt change
PHP HOW-TO



-->
<author>Al Dev (Alavoor Vasudevan) 
       <htmlurl url="mailto:
	   		alavoor@yahoo.com
			" name="
			alavoor@yahoo.com
		">
<date>v5.0, 14 May 2000
<abstract>
Questo documento dice come sviluppare i programmi di PHP ed anche come migrare 
tutte le applicazioni GUI Windows 95 a un potente PHP + HTML + DHTML + XML + 
Java applets + Javascript. Le informazioni in questo documento si applicano 
per tutti i sistemi operativi dove PHP è sopportato che sono - Linux, 
Windows 95/NT,OS/2, tutti le varianti di Unix come Solaris, HPUX, 
AIX, SCO, Sinix, BSD, etc.
</abstract>

<!-- Indice -->
<toc>

<!-- Inizio del documento -->

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Introduzione
-->
<sect>Introduzione
<p>
PHP sta per <bf>'Pre-Processore di Hypertesti'</bf> ed è un linguaggio di 
scipting e di programmazione server parte di HTML. PHP è uno strumento che 
permette di creare pagine web dinamiche. Le pagine web abilitate PHP sono 
trattate solo come pagine HTML regolari e si possono crearLE e redigerle allo 
stesso modo in cui si creano pagine HTML regolari.

PHP fu mantenuto un linguaggio per computer <bf>"top secret e strettamente 
confidenziale"</bf> da molte compagnie nel mondo , ma ora è divenuto il più 
conosciuto e il più largamente usato linguaggio di scripting per web, 
internet, e-commerce e progetti business-to-business. Anche oggi molte 
compagnie in competizione mantengono il linguaggio PHP come una questione 
strettamente riservata non rivelandola ad estranei (i concorrenti).

PHP prenderà d'assalto il mondo intero e prenderà l'industria IT con sorpresa!!
La potenza di PHP è che è cross-platform e gira dappertutto!!
Gira su  Linux, Windows 95/98/NT, Windows 2000, Solaris, HPUX e tutte le
varianti di unix. PHP è scrivere una volta e utilizzarle dovunque e 
dappertutto. Gira su molti web-server Apache, Microsoft IIS, etc..

PHP gira da 5 a 20 volte più veloce di Java!! E' estremamente facile da usare 
e si possono sviluppare applicazioni web/e-commerce molto complesse molto 
rapidamente in un periodo molto breve di tempo.

Ha caratteristiche ad oggetti orientati e prende le migliori caratteristiche 
di Java,C++, PERL e linguaggio "C". Il linguaggio PHP è un matrimonio delle
migliori caratteristiche da Java, C++, PERL e C.

PHP è la vera <bf> gemma </bf> di tutti i linguaggi di scripting e di 
programmazione , si vuole che divenga la "MECCA" mondiale per i programmatori!!
PHP ha un enorme base utente e un enorme base per lo sviluppatore poichè gira 
sia su Window95/NT e tutte le varianti di Unix.

PHP può essere compilato e ottimizzato per far si che esso giri anche 
più veloce utilizzando lo Zend Optimizer. Zend optimizer è integrato 
con PHP in PHP versione 4.0.

Si userebbe normalmente una combinazione di PHP (70% code) + HTML/DHTML/XML 
(25% code) + Javascript (5% parte di codice cliente di convalida) per i 
vostri progetti di e-commerce.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Scaricamento di PHP <label id = "Scaricamento di PHP">
-->
<sect> Scaricamento di PHP<label id = "Scaricamento PHP">
<p>
<itemize>
<item> Sito principale di PHP <url url="http://www.php.net">
<item> Risorse di PHP <url url="http://ils.unc.edu/web-db/php/links.html">
<item> Codice di scambio di PHP - <url url="http://px.sklar.com">
</itemize>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Installazione di PHP <label id = "Installazione di PHP">
<p>
Vedere la guida di installazione e le istruzioni al sito principale di 
PHP <url url="http://www.php.net"> o il file INSTALL nello stesso pacchetto
scaricato.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Tutoriale di PHP <label id = "Tutoriale di PHP">
-->
<sect> Tutoriale di PHP <label id = "Tutoriale di PHP">
<p>
In questo tutoriale noi presumiamo che il vostro server abbia il supporto per
PHP attivato e che tutti i files che finiscono in .php3 siano manipolabili da 
PHP. 

La vostra prima pagina abilitata PHP:  
Create un file chiamandolo hello.php3 e in esso mettete le seguenti linee:
<code>
      <html>< head>< title >PHP Test< /title >< /head >
      < body>
      <?php echo "Hello World<P>"; ?>
      < /body>< /html>
</code>

Notate che questo non è come uno script CGI. Pensate ad esso così come a un 
normale file HTML al quale capiti di avere un raccolta speciale di 
identificatori disponibili per voi.

Se voi provaste questo esempio e esso non dia nessun risultato, il caso è 
che il  server dove siete non ha PHP abilitato. Chiedete al vostro 
amministratore di abilitarlo per voi.

Il punto dell'esempio è quello di mostrare il formato speciale degli 
identificatori di PHP. In questo esempio noi usammo <?php per indicare 
la partenza degli identificatori di PHP. Poi noi mettemmo l'identificatore 
PHP e sinistro alla modalità PHP per aggiungere l'istruzione di chiusura, ? >. 
Voi potete saltare dentro e fuori dalla modalità PHP in un file HTML come 
voi volete.

Noi stiamo andando a controllare che genere di browser la persona che vede 
la pagina sta usando. Per far ciò noi controlliamo la stringa di agente 
utente che il browser invia come parte della sua richiesta. L'informazione è 
immagazzinata in una variabile. Le variabili cominciano sempre con un simbolo 
di dollaro in PHP. La variabile alla quale noi siamo interessati è  
$HTTP_USER_AGENT. Per visualizzare questa variabile noi possiamo fare 
semplicemente:
<code>
      <?php echo $HTTP_USER_AGENT; ?>
</code>

Per il browser che state usando per vedere questa pagina, questo visualizza:

     Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)

Ci sono molte altre variabili che sono messe a punto automaticamente dal 
vostro web server .Nè potete trovare una lista completa attraverso la 
creazione di un file come questo.

<code>
      <?php phpinfo()?>
</code>

Dunque caricando questo file nel vostro browser ,vedete una pagina piena di 
informazioni su PHP ,insieme ad un elenco di tutte le variabili disponibili 
per voi.

Potete inserire dichiarazioni multiple di PHP all'interno di un'istruzione 
PHP e creare piccoli blocchi di codice che fanno come un singolo echo. 
<code>
      <?php
      if(strstr($HTTP_USER_AGENT,"MSIE")) {
          echo "Voi state usando Internet Explorer<br>";
      }
      ?>
</code>

Possiamo seguire questo passo ulteriore e mostrare come , potete saltare
dentro e fuori dalla modalità di PHP come anche nel mezzo di un blocco PHP:

<code>
	<?php
	if(strstr($HTTP_USER_AGENT,"MSIE")) 
	{
		?>
		< center>< b>Voi state usando Internet Explorer< /b>< /center>
		<?
	} 
	else 
	{
		?>
		< center>< b>Voi non state usando Internet Explorer< /b>< /center>
		<?
	}
	?>
</code>
Invece di usare un'istruzione di eco PHP per far risultare qualche cosa, 
saltiamo fuori dalla modalità PHP e inviamo proprio direttamente HTML. 
Il punto importante e punto forte da notare qui è che il flusso logico dello 
script rimane intatto. Solo uno dei blocchi HTML finirà per inviato 
all'osservatore. Eseguendo questo script risulta adesso che:

                       Voi state usando Internet Explorer

Relazioni con i moduli

Una delle più potenti caratteristiche di PHP è il modo con il quale manipola 
i moduli HTML. Il concetto di base che è importante capire è che qualsiasi 
elemento di un modulo in un modulo risulterà automaticamente in una variabile
con lo stesso nome come l'elemento che era creato sulla pagina di arrivo.
Questo probabilmente suona confuso,così qui c'è un esempio. Si supponga di 
avere una pagina con un modulo come questa:
<code>
      <form action="action.php3" method="POST">
      Your name: <input type=text name=name>
      You age: <input type=text name=age>
      <input type=submit>
      < /form>
</code>
Non c'è niente di speciale su questo modulo. E' un modulo liscio HTML senza 
identificatori speciali di alcun tipo. Quando l'utente scrive in questa form 
e clicca su pulsante di invio, la pagina action.php3 è chiamata. In questo file
avreste qualcosa come questo:
<code>
      Hi <?php echo $name?>.  You are <?php echo $age?> years old.
</code>
Sorpresa!! Le variabili $name e $age sono automaticamente inserite per voi da 
PHP !!
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Strumenti IDE per PHP <label id = "PHP IDE">
-->
<sect> Strumenti IDE per PHP <label id = "PHP IDE">
<p>
Molti editor di HTML sono supportati da PHP : 
<itemize>
<item>Blue Fish <url url="http://bluefish.linuxave.net" >
<item>Coffee cup <url url="http://www.coffeecup.com/linux" >
<item>Dreamweaver <url url="http://www.dreamweaver.com" >
<item>Amaya <url url="http://www.w3.org/Amaya" >
<item>Homesite <url url="http://www.homesite.com" >
<item>Hotdog <url url="http://www.hotdog.com" >
<item> Zend Optimizers <url url="http://www.zend.com">
imitations<item> Zend Compilers <url url="http://www.zend.com" >
</itemize>
Nel prossimo futuro ogni editor HTML e XML supporteranno gli strumenti del
"Rapido sviluppo di applicazioni" di PHP.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> ctags per PHP !! <label id = "ptags">
-->
<sect> ctags per PHP ! Sorpresa!!! <label id = "ptags">
<p>
Gli identificatori sono estremamente preziosi e sono usati per la navigazione 
nel codice sorgente dentro gli editor come vi, emacs, CRiSP,NEdit etc...
Se avete programmato molto in C, C++ o Java è probabile che avrete usato 
il programma <bf>ctags</bf> per creare identificatori.Per vedere la pagina 
del manuale online,digitate 'man ctags' al bash prompt di linux/unix.

Il programma <bf>ptags</bf> per PHP è dato sotto, da poter usare per creare 
gli identiticatori per il codice sorgente PHP. 
La vostra <bf>produttività migliorerà da 3 a 4 volte</bf> se voi usate 
<bf>ptags</bf>.

Vedete anche Vim color text editor per PHP, C, C++
al <url url="http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html">
<code>
// Salvate questo file come ptags.cpp and compilatelo con
// 		g++ -o ptags ptags.cpp
//*****************************************************************
// La poliza di copyright è GNU/GPL ma addizionalmente richiede 
// che voi includiate il nome dell'autore e l'email in tutte le copie
// Autore : Al Dev Email: alavoor@yahoo.com
// Uso : ptags *.php3 *.inc
// 		   Questo genererà un file chiamato tags
//*****************************************************************
#include <iostream.h>
#include <fstream>
#include <stdio.h> // for sprintf
#include <stdlib.h> // for system
#include <string.h> // for memset
#include <ctype.h> // for isspace

#define	BUFF_LEN  1024
#define	LOCATION  9

char *ltrim(char *dd);
char *rtrim(char *ee);

main(int argc, char **argv)
{
	if (argc < 2)
	{
		cerr << "\nUsage: " << argv[0] << " file .... " << endl;
		exit(0);
	}

	char fname[100] = "tag_file.out";
	FILE	*fpout;
	ofstream    fout(fname);
	if (fout.fail())
	{
		cerr << "\nError opening file : " << fname << endl;
		exit(-1);
	}
	//fpout = fopen(fname, "w");

	for (int ii = 1; ii < argc; ii++)
	{
		/*
		char buff[2024];

		sprintf(buff, "\\rm -f %s; ls %s > %s 2>/dev/null", outfile, argv[1], outfile);
		cout << "\nbuff = " << buff << endl;

		system(buff);
		fclose(fp);
		*/
		FILE *fpin = NULL;
		fpin = fopen(argv[ii], "r");
		if (fpin == NULL)
		{
			cerr << "\nError opening file : " << argv[ii] << endl;
			exit(-1);
		}
		char buff[BUFF_LEN + 100];
		memset(buff, 0, BUFF_LEN +10);
		for ( ; fgets(buff, BUFF_LEN, fpin) != NULL; )
		{
			char aa[BUFF_LEN + 100];
			memset(aa, 0, BUFF_LEN +10);
			strcpy(aa, buff);
			ltrim(aa);

			// Rimuovete le nuove linee finali..
			{
				int tmpii = strlen(aa);
				if (aa[tmpii-1] == '\n')
					aa[tmpii-1] = 0;
			}
			//cout << "aa is : " << aa << endl;
			if (strncmp(aa, "function ", LOCATION) != 0)
				continue;
			//cout << buff << endl;

			// Il file di uscita dell'identificatore è come -
			// al2	al.c	/^al2()$/;"	f
			{
				char bb[BUFF_LEN + 100];
				memset(bb, 0, BUFF_LEN +10);
				strcpy(bb, & aa[LOCATION]);
				char *cc = bb;
				while (cc != NULL && *cc != '(')
					*cc++;
				*cc = 0;
				cc = rtrim(bb);
				//cout << "bb is : " << bb << endl;
				//cout << cc << "\t" << argv[ii] << "\t" << "/^" << aa << "$/;\"\tf" << endl;
				fout << cc << "\t" << argv[ii] << "\t" << "/^" << aa << "$/;\"\tf" << endl;
				//fprintf(fpout, "%s\t%s\t/^%s$/;\"f\n", cc, argv[ii], aa );
			}

			memset(buff, 0, BUFF_LEN +10);
		}
		fclose(fpin);
	}
	fout.flush();
	fout.close();
	//fclose(fpout);

	// Classifica e genera il file dell'identificatore
	{
		char tmpaa[1024];
		sprintf(tmpaa, "sort %s > tags; \\rm -f %s", fname, fname);
		system(tmpaa);
	}
}

char *ltrim(char *dd)
{
    if (dd == NULL)
        return NULL;

    while (isspace(*dd))
        dd++;
	
	return dd;
}

char *rtrim(char *ee)
{
    if (ee == NULL)
        return NULL;

	int tmpii = strlen(ee) - 1;
	for (; tmpii >= 0 ; tmpii--)
	{
		if (isspace(ee[tmpii]) )
		{
			//cout << "\nis a space!!" << endl;
			ee[tmpii] = 0;
		}
	}
	return ee;
}
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Debugging di PHP <label id = "debugphp">
-->
<sect> Debugging di PHP <label id = "debugphp">
<p>
Per il debug i programmi PHP creano un file "debug2.inc" avente le 
seguenti funzioni :
<code>
<?php

/* definisce questa variabile, per prevenire doppie dichiarazioni.	*/
if (!defined("_DEBUG2_DEFINED_")) 
{
	define("_DEBUG2_DEFINED_", 1 );
}
else
	return; // se questo è già incluso allora ritorna

# file name : debug2.inc
# Funzioni per il debuging del codice sorgente di PHP
#*****************************************************************
# La poliza di copyright è GNU/GPL ma addizionalmente richiede 
# che voi icludiate il nome dell'autore e l'email su tutte le copie
# Author : Al Dev Email: alavoor@yahoo.com
#*****************************************************************

# Utilizzo di questa funzione -
# Nel vostro codice sorgente mettere put something like -
# debug2_(__FILE__, __LINE__, "f_somevariable", $f_somevariable);
# E questo genererà un output nel file debug.out.

//funzione debug2_($fname, $lname, $debug_var, $debug_value=0) {}

// Mettere i permessi read, exec per tutti nella directory /debug2_logs
// chmod a+rwx /debug2_logs
// Ma qui voi necessitate di aprire il file in modo append.
$fp_debug2 = fopen("/debug2_logs/debug.out", "a");
if ($fp_debug2 == false)
{
	print "<b>File open failed - global.var.inc<b>";
	exit;
}

function debug2_($fname, $lname, $debug_var, $debug_value=0)
{
	global $fp_debug2;

	// print "<br> debug_value is : $debug_value <br>";
	if (!$debug_value)
	{
		fwrite($fp_debug2, "\n ". $fname ."  ". $lname .": $debug_var");
	}
	else
	{
		fwrite($fp_debug2, "\n ". $fname . " ". $lname .": $debug_var = $debug_value");
	}
	//print "<br> f_cookie is : $f_cookie <br>";
}

// Nella prima pagina, che è generalmente index.php3 
// troncate il file debug2_logs all'inizio del codice
function init_debug_file()
{
	global $fp_debug2;

	$fp_debug2 = fopen("/debug2_logs/debug.out", "w");
	if ($fp_debug2 == false)
	{
		print "<b>File open failed - global.var.inc<b>";
		exit;
	}
	system("chmod a+rwx /debug2_logs/debug.out");
}

?>
</code>

Nella pagina iniziale del codice sorgente PHP che è generalmente 
index.php3, mettete una linea come 

<code>
<?php
	include ("debug2.inc");

	init_debug_file();
	// tutti gli altri comandi seguono qui ...
	// ...........
?>
</code>

Per visualizzare i valori di debug, nel vostro file di codice sorgente di PHP,
mettete le chiamate debug2_() come illustrato sotto:

<code>
<?php
include ("debug2.inc");
debug2_(__FILE__, __LINE__, "f_somevariable", $f_somevariable);

function aa()
{
	$aa = 8;
	debug2_(__FILE__, __LINE__, "aa", $aa);
}
?>
</code>

Quando eseguite il programma PHP l'output sarà tracciato in un file 
chiamato debug.out che dà il nome di file, il numero di linea, il nome di
variabile e il suo valore.

Usate il debug2_() generosamente nel vostro codice. L'uso delle chiamate
di debug2_() nel vostro programma <bf>NON</bf> avranno impatto sulla 
produzione finale del codice e non avranno impatto sulle prestazioni perchè 
esse saranno filtrate come descritto sotto. Voi potete utilizzare
le funzioni copia e incolla per risparmiare tempo a scrivere le chiamate 
debug2() o utilizzare le caratteristiche 'yank to buffer' del  Vi editor 
e incollare.

Quando  avrete sviluppato e testato e quando siete pronti per disporre 
sul server di produzione, filtrate le chiamate debug2_ calls dal
vostro codice sorgente. Dal prompt unix-
<code>
bash$ mkdir production
bash$ grep -v debug2_  filea.php3 > production/filea.php3
</code>
Per un gruppo grande di file-
<code>
bash$ mkdir production
bash$ ls *.php3 | while read ans 
do 
	grep -v  debug2_ $ans > production/$ans
done
</code>
Ora copiate i file dalla produzione all'area di sviluppo.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Limitazioni di PHP
-->
<sect> Limitazioni di PHP
<p>
Tutto ha limitazione o svantaggi e PHP non fa eccezione.
Le seguenti sono le limitazioni di PHP (siate così <bf>AVVERTITI !!</bf>)
<enum>
<item> PHP non è 100 % puro linguaggio scripting orientato agli oggetti.
PHP è buono se la sua taglia del codice non eccede le 3,00,000 linee.
La manutenzione di un codice più grande di 1,00,000 linee diviene molto
difficile.
<item> PHP NON dà le prestazioni del liguaggio "C" or "C++". Perchè esso è
un linguaggio scripting e interpretato ed esso avrà un bit slower come i
programmi ottimizzati "C++". Per alte prestazioni, dovete usare "C++" 
e CGI-veloci con connessioni database/webserver pooling e usare il compilatore
C++ ottimizzando l'opzione "-O3". 
Zend optimizer in PHP 4 velocizzerà le prestazioni di PHP per certe estensioni.
</enum>

D'altra parte, PHP ha diversi vantaggi e i suoi vantaggi hanno maggior peso
delle sue limitazioni -
<enum>
<item> Voi potete con vera rapidità sviluppare applicazioni Web in PHP 
poichè il compilare e il collegare è eliminato nel linguaggio scripting di PHP.
<item> Le applicazioni PHP sono veramente stabili e questo fatto non dipende
dalla tecnologia del browser diversa dalle applicazioni Javascript che 
dipendono dai browsers.
PHP vi permette la libertà di selezionare delle piattaforme server e il 
browser non ha bisogno di conoscere che la pagina HTML è generata da PHP!!
<item> PHP ha un eccellente connettività database a tutti i SQL database 
server.
<item> PHP ha parziale supporto per le caratteristiche ad oggetto orientato
<item> PHP ha caratteristiche sintattiche come C++, Perl, Javascript e ha
programmi come "ptags/ctags" per navigare nel codice sorgente
<item> PHP ha Zend optimizer che velocizza le prestazioni
<item> PHP gira su tutti gli unix, linux, Windows 95/NT/2000 ed è molto 
potente come ASP, JSP e altri.
<item> PHP ha una vera larga base di uso e base di sviluppo.
</enum>

<bf>AVVERTENZA: </bf> Se volete un linguaggio scripting orientato agli
oggetti allora DOVETE considerare <bf>Python</bf>. Il 'Python' è un
liguaggio scripting orientato agli oggetti dal alto campo. Potreste
usare l'applicazione WEB server chiamta 'Zope' che è disponibile al -
<url url="http://www.zope.org"> 
e python lo è a
<url url="http://www.python.org">
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> URL relative
-->
<sect> URL relative
<p>
Visitate i seguenti siti che sono relativi a C, C++ -
<itemize>
<item> Vim color text editor per C++, C <url url="http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html">
<item> SQL database server per PHP PostgreSQL <url url="http://metalab.unc.edu/LDP/HOWTO/PostgreSQL-HOWTO.html">
<item> Codice sorgente del sistema di controllo CVS HOWTO per programmi C++ 
<url url="http://metalab.unc.edu/LDP/HOWTO/CVS-HOWTO.html">
<item> Linux goodies sito principale <url url="http://www.aldev.8m.com">
<item> Linux goodies sito mirror <url url="http://aldev.webjump.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Altri formati di questo documento
-->
<sect> Altri formati di questo documento
<p>
Questo documento è pubblicato in 11 differenti formati con nome - DVI, 
Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, 
RTF(Rich Text Format), Testo-pieno, pagine man di Unix e SGML.
<itemize>
<item>
Potete trovare questo documento HOWTO come un singolo file tar compresso
in formati HTML, DVI, Postscript o SGML da -
<url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/">
 o 
<url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/">

<item>Il formato in pieno testo è in: <url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">
o 
<url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">

<item>Traduzioni in altre lingue come Francese, Tedesco, Spagnolo, 
Cinese, Giapponese sono in
<url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">
o <url url="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">
Ogni aiuto da voi  per tradurre in altri linguaggi è il benvenuto.
</itemize>
Il documento è scritto utilizzando uno strumento chiamato "SGML tool" 
il quale può essere ottenuto da - 
<url url="http://www.xs4all.nl/~cg/sgmltools/">
Compilando il sorgente voi troverete i seguenti comandi come 
<itemize>
<item>sgml2html PHP-HOWTO.sgml     (per generare html file)
<item>sgml2rtf  PHP-HOWTO.sgml     (per generare RTF file)
<item>sgml2latex PHP-HOWTO.sgml    (per generare latex file)
</itemize>

Questo documento è situato in -
<itemize>
<item> <url url="http://metalab.unc.edu/LDP/HOWTO/PHP-HOWTO.html">
</itemize>

Potete trovare questo documento ai seguenti siti mirrors -
<itemize>
<item> <url url="http://www.caldera.com/LDP/HOWTO/PHP-HOWTO.html">
<item> <url url="http://www.WGS.com/LDP/HOWTO/PHP-HOWTO.html">
<item> <url url="http://www.cc.gatech.edu/linux/LDP/HOWTO/PHP-HOWTO.html">
<item> <url url="http://www.redhat.com/linux-info/ldp/HOWTO/PHP-HOWTO.html">

<item> Altri siti mirror vicino a voi (network-address-wise) possono essere
trovati al
<url url="http://metalab.unc.edu/LDP/hmirrors.html">
selezionate un sito e andate alla directory /LDP/HOWTO/PHP-HOWTO.html
</itemize>


Per vedere il documento in formato dvi,usate il programma xdvi. Il programma
xdvi è situato nel pacchetto tetex-xdvi*.rpm in Redhat Linux il quale può 
essere localizzato attrverso ControlPanel | Applications | Publishing | 
TeX i pulsanti di menù.
<tscreen><verb>
	Per leggere il documento dvi date il comando -
		xdvi -geometry 80x90 howto.dvi
	E ridimensionare la finestra con il mouse. Vedete la pagina del su 
        xdvi. Per navigare usate i tasti frecce, i tasti Pagina sù, Pagina 
        giù, potete usare i tasti lettera 'f', 'd', 'u', 'c', 'l', 'r', 
        'p', 'n' per muovere su, giù, in centro, pagina seguente, pagina
        precedente ecc.
	Per chiudere il menù premere 'x'.
</verb></tscreen>
Potete leggere il file postscript usando il programma 'gv' (ghostview) o 
'ghostscript'.Il programma ghostscript è nel pacchetto ghostscript*.rpm e 
il programma gv e nel pacchetto gv*.rpm in Redhat Linux il quale può essere
localizzato attraverso i pulsanti ControlPanel | Applications | Graphics menu. 
Il programma gv è molto più user friendly che ghostscript.
Ghostscript and gv anche disponibile su altre piattaforme come OS/2,
Windows 95 and NT.

<itemize>
<item>Trovate ghostscript per Windows 95, OS/2, e per tutti i sistemi 
operativi su <url url="http://www.cs.wisc.edu/~ghost">
</itemize>

<tscreen><verb>
	Per leggere il documento postscript date il comando -
		gv howto.ps

	Per usare ghostscript date -
		ghostscript howto.ps
</verb></tscreen>

Potete leggere il formato HTML usando Netscape Navigator, Microsoft Internet
explorer, Redhat Baron Web browser o ogni altro web browsers.

Potete leggere  l'output latex, LyX usando LyX un interfaccia "X-Windows" per 
latex.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Copyright
-->
<sect> Copyright
<p>
Copyright policy is GNU/GPL as per LDP (Linux Documentation project).
LDP is a GNU/GPL project.
Additional requests are - Please retain the author's name, email address
and this copyright notice on all the copies. If you make any changes 
or additions to this document then you please 
intimate all the authors of this document.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix A  Database Wrapper Example <label id="Appendix A">
-->
<sect> Appendix A Database Wrapper Example <label id="Appendix A">
<p>
Submitted by: Barton Greg 
       <htmlurl url="mailto:
			greg@createtech.com
			" name="
			greg@createtech.com
		">
To get this file, in the web-browser, save this file as 'Text' type
as pgsql.lib
<code>
This  is  a  database   wrapper  for  PostgreSQL,  but   
can  be  simply  modified  for  any  other   database  type.


<?php

if ($dbObjDefined  !=  1)
{
	$dbObjDefined  =  1;

	// Wrapper  class  for  database  calls
	class  dbObj
	{
		// Connection  handle  to  database
		var  $conn;

		// Default  connection  parameters
		var  $host  =  "YourSite.com";
		var  $user  =  "johndoe";
		var  $password  =  "pwd";
		var  $port  =  "5432";
		var  $dbname  =  "MyDB";

		// Open  initial  connection.  $params  is  
		// an  associative  array  holding
		// parameters  to  the  pg_Connect  function.
		function  init($params)
		{
			if(isset($parame[host]))
				$host  =  $parame[host];
			else
				$host  =  $this->host;

			if(isset($parame[user]))
				$user  =  $parame[user];
			else
				$user  =  $this->user;

			if(isset($parame[password]))
				$password  =  $parame[password];
			else
				$password  =  $this->password;

			if(isset($parame[port]))
				$port  =  $parame[port];
			else
				$port  =  $this->port;

			if(isset($parame[dbname]))
				$dbname  =  $parame[dbname];
			else
				$dbname  =  $this->dbname;

			$this->conn  =  pg_Connect ( "  host=$host  user=$user  password=$password  port=$port  dbname=$dbname ");
		}

		// Send  SQL  to  database  connection.
		// Return  recordset  object  on  success.
		// Return  0  on  failure.
		function  exec($SQL)
		{
			$this->resultset  =  pg_Exec($this->conn,  $SQL);

			if  ($this->resultset)  
			{
				$recset  =  new  recordset;
				$recset->init($this->resultset);
				return  $recset;
			}
			else  
			{
				return  0;
			}
		}

		function valid()
		{
			return $this->resultset;
		}

		// Close  connection  to  database
		function  free()
		{
			pg_close($this->conn);
		}
	};

	/*
	** This  is  a  simple  recordset  class  which  can  be
	** traversed  using  next(),  prev(),  and  current()  methods.
	** It  is  initialized  from  a  resultset  returned  from  the
	** function  "pg_Exec"  or  can  be  generated  by  a  call  to  the
	** exec  method  from  the  dbObj class given above.
	** Below "Tuples" means rows.
	*/
	class  recordset
	{
		var  $resultset;
		var  $index;
		var  $numFields;
		var  $numTuples;

		function  init($newResultset)
		{
			$this->resultset  =  $newResultset;
			$this->index  =  0;
			$this->numFields  =  pg_NumFields($this->resultset);
			$this->numTuples  =  pg_NumRows($this->resultset);
		}

		// Used in display() below
		function valid()
		{
			return $this->resultset;
		}

		// Get  a  value  by  row  number  and  either  
		// column  name  or  column  number
		function  getVal($row,  $col)
		{
			return  pg_Result($this->resultset,  $row,  $col);
		}

		// Return  an  array  of  field  names
		function  getFields()
		{
			for ($i=0;  $i < $this->numFields;  $i++)
				$retArray[] = pg_FieldName($this->resultset,  $i);
			return  $retArray;
		}

		// Get  number  of  columns  in  resultset
		function  getNumFields()
		{
			return  $this->numFields;
		}

		// Get  a  tuple  (associative  array  of  
		// column  values)  by  row  number
		function  getTupleDirect($row)
		{
			for ($i=0;  $i < $this->numFields;  $i++)
			{
				$retArray[pg_FieldName($this->resultset,  $i)]  = 
					pg_Result($this->resultset,  $row,  $i);
			}
			return  $retArray;
		}

		// Get  an  array  filled  with  all  values  in  a  column
		// (using  either  column  name  or  column  number)
		function  getColumn($col)
		{
			for ($i=0; $i < $this->numTuples; $i++)
				$retArray[]  =  pg_Result($this->resultset,  $i,  $col);
			return  $retArray;
		}

		// Return  the  number  of  records  in  the  recordset
		function  getNumTuples()
		{
			return  $this->numTuples;
		}

		// Get  tuple  pointed  to  by  the  current  index
		function  getTuple()
		{
			if ($this->index >= 0  &&  $this->index  <  $this->numTuples)
				return  $this->getTupleDirect($this->index);
			else
				return  0;
		}

		function valueof($col)
		{
			if ($col < $this->numFields)
			{
				return pg_Result($this->resultset,  $this->index,  $col);
			}
			else
			{
				return "";
			}
		}

		// Reached last row - end of rows ? Used in display() below
		function eof()
		{
			return $this->index == $this->numTuples;
		}

		// Return  1  if  index  is  within  bounds  of  the  recordset
		function  current()
		{
			if ($this->index >= 0  &&  $this->index  <  $this->numTuples)
				return  1;
			else
				return  0;
		}

		// Increment  index. Used in display() below
		function  next()
		{
			if ($this->index < $this->numTuples)
			{
				$this->index++;
				return  1;
			}
			else
			{
				return  0;
			}
		}

		// Decrement  index
		function  prev()
		{
			if ($this->index  >=  0)
			{
				$this->index--;
				return  1;
			}
			else
			{
				return  0;
			}
		}

		// Reset  index  to  0 - See also first()
		function  reset()
		{
			$this->index  =  0;
		}

		// See also reset(). Used in display() below
		function  first()  
		{
			$this->index  =  0;
		}

		function last()
		{
			$this->index = $this->numTuples -1 ;
		}

		// Used in display() below
		function showheader($col, $fmt = "")
		{
			printf("\t< th %s>%s< /th >\n", $fmt, 
			is_string($col) ? $col : pg_fieldname($this->resultset, $col));
		}

		// Used in display() below
		function showvalue($col, $fmt =  "", $def =  "&nbsp;")
		{
			$v = $this->valueof($col);
			printf( "\t< td %s>%s< /td>\n", $fmt, $v ==  "" ? $def : $v);
		}

		function showurl($col, $fmt =  "")
		{
			$v = $this->valueof($col);
			if ( $v !=  "" ) 
			{
				printf("\t< td %s>&nbsp;< /td>\n", $fmt);
			}
			else 
			{
				printf( "\t< td %s>< a href=%s>%s< /a>< /td>\n", $fmt, $v, $v);
			}
		}

		function display()
		{
			if (!$this->valid() ) 
			{
				return;
			}

			printf( "<table cellspacing=1 cellpadding=1 border=1>\n");

			printf( "<tr>\n");
			for ($c = 0; $c < $this->cols; $c++ )
			{
				$this->showheader($c);
			}
			printf( "< /tr>\n");

			$this->first();
			while (!$this->eof())
			{
				printf( "<tr>\n");

				for ($c = 0; $c < $this->cols; $c++)
				{
					$this->showvalue($c);
				}

				printf( "< /tr>\n");
				$this->next();
			}
			printf("< /table\n");
		}

		// Free  memory  allocated  to  recordset.
		function  free()
		{
			pg_Freeresult($this->resultset);
		}
	};
}

?>

</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix B  SQL abstraction Example <label id="Appendix B">
-->
<sect> Appendix B SQL abstraction Example <label id="Appendix B">
<p>
Submitted by: 
Gianugo Rabellino 
       <htmlurl url="mailto:
			nemorino@opera.it
			" name="
			nemorino@opera.it
		">
To get this file, in the web-browser, save this file as 'Text' type
as sqlabst.lib
<code>

PX: PHP Code Exchange
<?php

/*
*    SAL - SQL Abstraction Library
*           version 0.01
*/

/*
** Set the variable $dbtype to any of the following
** values: MySQL, mSQL, Postgres, ODBC before including this library
*/
// $dbtype = "MySQL"; 
// $dbtype = "mSQL"; 
// $dbtype = "PostgreSQL"; 
// $dbtype = "ODBC"; 

// SQL_connect($host, $user, $password, $db)
// returns the connection ID

function SQL_connect($host, $user, $password, $db)
{
	global $dbtype;

	switch ($dbtype) 
	{
		case  "MySQL":
			$conn=mysql_pconnect($host, $user, $password);
			mysql_select_db($db);
			return $conn;
			break;;

		case  "mSQL":
			$conn=msql_pconnect($host);
			msql_select_db($db);
			return $conn;
			break;;

		case  "PostgreSQL":
			$conn=pg_pconnect($host, "5432", "",$db);
			return $conn;
			break;;

		case  "ODBC":
			$conn=odbc_pconnect($db,$user,$password);
			return $conn;
			break;;

		default:
			$conn=mysql_pconnect($host, $user, $password);
			mysql_select_db($db);
			return $conn;
			break;;
	}
}

// SQL_query($host, $user, $password, $db)
// executes an SQL statement, returns a result identifier
function SQL_query($query, $id)
{
	global $dbtype;
	switch ($dbtype) 
	{
		case  "MySQL":
			$res=mysql_query($query, $id);
			return $res;
			break;;

		case  "mSQL":
			$res=msql_query($query, $id);
			return $res;
			break;;

		case  "PostgreSQL":
			$res=pg_exec($id,$query);
			return $res;
			break;;

		case  "ODBC":
			$rid=odbc_prepare($id,$query);
			$res=odbc_execute($rid);
			return $res;
			break;;

		default:
			$res=mysql_query($query, $id);
			return $res;
			break;;
	}
}

// SQL_num_rows($host, $user, $password, $db)
// given a result identifier, returns the number of affected rows
function SQL_num_rows($res)
{
	global $dbtype;

	switch ($dbtype) 
	{
		case  "MySQL":
			$rows=mysql_num_rows($res);
			return $rows;
			break;;

		case  "mSQL":
			$rows=msql_num_rows($res);
			return $rows;
			break;;

		case  "PostgreSQL":
			$rows=pg_numrows($res);
			return $rows;
			break;;

		case  "ODBC":
			$rows=odbc_num_rows($res);
			return $rows;
			break;;

		default:
			$rows=mysql_num_rows($res);
			return $rows;
			break;;
	}
}


// SQL_fetchrow($res,$row)
// given a result identifier, returns an array with the resulting row
// Needs also a row number for compatibility with PostgreSQL
function SQL_fetch_row($res, $nr)
{
	global $dbtype;

	switch ($dbtype) 
	{
		case  "MySQL":
			$row = array();
			$row = mysql_fetch_row($res);
			return $row;
			break;;

		case  "mSQL":
			$row = array();
			$row = msql_fetch_row($res);
			return $row;
			break;;

		case  "PostgreSQL":
			$row = array();
			$row = pg_fetch_row($res,$nr);
			return $row;
			break;;

		case  "ODBC":
			$row = array();
			$cols = odbc_fetch_into($res, $nr, &$row);
			return $row;
			break;;

		default:
			$row = array();
			$row = mysql_fetch_row($res);
			return $row;
			break;;
	}
}

// SQL_fetch_array($res,$row)
// given a result identifier, returns an associative array
// with the resulting row using field names as keys.
// Needs also a row number for compatibility with PostgreSQL.
function SQL_fetch_array($res, $nr)
{
	global $dbtype;

	switch ($dbtype) 
	{
		case  "MySQL":
			$row = array();
			$row = mysql_fetch_array($res);
			return $row;
			break;;

		case  "mSQL":
			$row = array();
			$row = msql_fetch_array($res);
			return $row;
			break;;

		case  "PostgreSQL":
			$row = array();
			$row = pg_fetch_array($res,$nr);
			return $row;
			break;;

		/*
		* ODBC doesn't have a native _fetch_array(), so we have to
		* use a trick. Beware: this might cause HUGE loads!
		*/

		case  "ODBC":
			$row = array();
			$result = array();
			$result = odbc_fetch_row($res, $nr);
			$nf = count($result)+2;  /* Field numbering starts at 1 */
			for ($count=1; $count < $nf; $count++) 
			{
				$field_name = odbc_field_name($res, $count);
				$field_value = odbc_result($res, $field_name);
				$row[$field_name] = $field_value;
			}
			return $row;
			break;;
	}
}

</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix C  PostgreSQL large object Example <label id="Appendix C">
-->
<sect> Appendix C PostgreSQL large object Example <label id="Appendix C">
<p>
Submitted by: 
PHP code exchange 
       <htmlurl url="mailto:
px@sklar.com
			" name="
px@sklar.com
		">
To get this file, in the web-browser, save this file as 'Text' type
as pgsql_largeobj.lib
<code>

PX: PHP Code Exchange - PostgreSQL large object access

<?
	$database = pg_Connect ( "",  "",  "",  "",  "jacarta");
	pg_exec ($database,  "BEGIN");
	$oid = pg_locreate ($database);
	echo ( "$oid\n");
	$handle = pg_loopen ($database, $oid,  "w");
	echo ( "$handle\n");
	pg_lowrite ($handle,  "foo");
	pg_loclose ($handle);
	pg_exec ($database,  "COMMIT");
	pg_close ($database);
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix D  User authentication Example <label id="Appendix D">
-->
<sect> Appendix D User authentication Example <label id="Appendix D">
<p>
To get this file, in the web-browser, save this file as 'Text' type
as user_pw.lib

From the PHP 3 Manual:
Works only if PHP is an Apache module.
Instead of simply printing out the $PHP_AUTH_USER and $PHP_AUTH_PW, 
you would probably want to check the username and password for 
validity. Perhaps by sending a query to a
database, or by looking up the user in a dbm file.

<code>
<?php
	if (!$PHP_AUTH_USER)
	{
		Header("WWW-authenticate: basic realm=\"My Realm\"");
		Header("HTTP/1.0 401 Unauthorized");
		echo "Text to send if user hits Cancel button\n";
		exit;
	}
	else
	{
		echo "Hello $PHP_AUTH_USER.<P>";
		echo "You entered $PHP_AUTH_PW as your password.<P>";
	}
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix E  Network admin Example <label id="Appendix E">
-->
<sect> Appendix E Network admin Example <label id="Appendix E">
<p>
To get this file, in the web-browser, save this file as 'Text' type
as network.lib

PHP: network adminstrator's best friend from <url url="http://www.phpWizard.net">

As a web-developer, you're probably used to such lovely tools as ping,
whois, nslookup etc. But what when you need one of those utilities at a
client's office and have no access to telnet? Good guess. Time to look
up the functions in the "Network" section of the PHP manual.

<bf>Socket operations: </bf>

The most important function there is fsockopen(). Using this function,
you can connect to any open port on a server and establish a socket
connection with it. The function's syntax is as following:
<code>
	int fsockopen(string hostname, int port, int [errno], string [errstr]);
</code>
The first two arguments are obvious, the next two are optional and used
for error handling. The "errno" and "errstr" should be passed by reference.
"Passing by reference" means that the original variable will get
modified. Normally, the content of a variable passed to a function
wouldn't be modified.

So, you could use this function to open a connection to a webserver and
print out the headers:
<code>
function get_headers($host, $path = "/")
{
	$fp = fsockopen ("$host", 80, &$errnr, &$errstr) or die("$errno: $errstr");
	fputs($fp,"GET $path HTTP/1.0\n\n");
	while (!$end)
	{
		$line = fgets($fp, 2048);
		if (trim($line) == "")
			$end = true;
		else
			echo $line;
	}
	fclose($fp);
}
</code>
In this example you see that you can apply any file operations (fread,
fwrite etc) to the the pointer you got using the fsockopen() call. Note
that the example realizes a HTTP/1.0 client - it won't work with
name-based virtual hosts.

<bf>Finger: </bf>
Naturally, you can also open connections to other ports. Writing a
small finger client with PHP is trivial therefore. Let's change the
example from above to query a finger daemon:
<code>
function finger ($host, $user)
{
	$fp = fsockopen($host, 79, &$errno, &$errstr) or die("$errno: $errstr");
	fputs($fp, "$user\n");
	while (!feof($fp))
		echo fgets($fp, 128);
	fclose($fp);
}
</code>

<bf>Whois: </bf>
Querying a whois server uses the same concept:
<code>
// domain is like "phpwizard.net"
function whois($domain, $server="whois.internic.net")
{
	$fp = fsockopen ($server, 43, &$errnr, &$errstr) or die("$errno: $errstr");
	fputs($fp, "$domain\n");
	while (!feof($fp))
		echo fgets($fp, 2048);
	fclose($fp);
}
</code>

<bf>Blocking and non-blocking operations: </bf>
But there's a problem with all those functions. They work fine if 
<enum>
<item> You have a conenction with low latency and 
<item> If the server you're connecting to is up and 
running. If not, your script will be busy until
it times out. The reason for this is that default socket connections
are blocking and don't time out. You can avoid these "hanging scripts"
by switching to non-blocking socket operations. The function
set_socket_blocking() does just that: it set all operations on a socket
(first parameter: socket pointer) to either blocking (second parameter:
true) or false (second parameter: false). Using non-blocking
operations, the finger function would like like this:
</enum>

<code>
	$fp = fsockopen($host, 79, &$errno, &$errstr) or die("$errno: [ ] $errstr");
	set_socket_blocking($fp, 0);
	fputs($fp, "$user\n");

	$stop = time() + $timeout;
	while (!feof($fp) && time() < $stop )
		echo fgets($fp, 128);
	fclose($fp);
</code>
Modifying these 3 functions to use non-blocking socket calls is left as
an exercise for you. 
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix F  Database Wrapper Examples <label id="Appendix F">
-->
<sect> Appendix F PostgreSQL Database Wrapper Examples <label id="Appendix F">
<p>
Submitted by: Joe Thong
       <htmlurl url="mailto:
		   darkjoe@softhome.net
			" name="
		   darkjoe@softhome.net
		">
Site URL: <url url="http://phpdb.linuxbox.com">

<bf>Description: </bf> A PHP database wrapper for various database 
servers with a powerful
Recordset for result data manipulation.  Database results 
are flushed automatically by phpDB.

To get this file, in the web-browser, save this file as 'Text' type
as phpDB-postgresql.lib
<code>
<?php
/*
Name: phpDB PostgreSQL module
Version: 1.02bR6
Description: A PHP database wrapper for various database 
	servers with a powerful recordset for result data 
	manipulation.  Database results are flushed 
	automatically by phpDB.  
*/

/* define this module, to prevent double class declaration.	*/
if (!defined("_PHPDB_ABSTRACT_LAYER")) {
	define("_PHPDB_ABSTRACT_LAYER", 1 );
}
else
	return;

//---------------------------------------
	 Class Name: phpDB
//---------------------------------------
class phpDB 
{
	/*	public variables	*/
	var $version = '1.02bR6'; // Version number of phpDB
	// This variable keeps what database type is going to 
	// be used.  Current supported database server are 
	// MySQL, MSQL, SQL Server, and Sybase
	var $databaseType = '';
	// Specifies which database is going to be used
	var $databaseName = ''; 
	// The hostname of the database server, port 
	// number is optional.  e.g: "db.devNation.com"
	var $hostname = '';	
	var $username = ''; // used to connect to the database server
	var $password = ''; // Password for the username

	// Private variables ------ starts with underscore
	// An array of executed querys. For results cleanup purposes.
	var $_queryIDList = array();
	// The returned link identifier whenever a 
	// successful database connection is made
	var $_connectionID	= -1;	
	// A variable which was used to keep the returned 
	// last error message.  The value will then returned 
	// by the errorMsg() function
	var $_errorMsg = '';
						
	// This variable keeps the last created result 
	// link identifier
	var $_queryID = -1;	
	// A boolean variable to state whether its a persistent
	// connection or normal connection
	var	$_isPersistentConnection = false;
	// Holds the newly created result object, 
	// returned via the execute() method
	var $_tempResultObj = '';	

	// A constructor function for the phpDB object.  
	// When initializing, specify the dbType i.e: "mysql",
	// "msql", "postgresql", "mssql", and "sybase"
	function phpDB($dbType = "postgresql") 
	{
		switch ($dbType) {
			case "mysql":
			case "msql":
			case "postgresql":
			case "mssql":
			case "sybase":						
			case "informix":						
				$this->databaseType = $dbType;
				break;
			default:
				return false;
		}			
	}
	
	// Returns: A positive link identifier on success, or 
	// false on error. 	Connect to the server with the provided 
	// arguments. The connection to the server will be closed 
	// when the script terminates, unless close() function is 
	// called beforehand
	function connect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$connString = "";
		$hostPieces = array();
		/*	Must specify the database argument	*/
		if (!$argDatabaseName) {	
			return false;
		}
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		$hostPieces = split(":", $this->hostname);
		if ($hostPieces[0]) {
			$connString .= "host=$hostPieces[0]";
			if (isset($hostPieces[1])) {
				$connString .= " port=$hostPieces[1]";
			}			
		}
	    if ($this->username) {
			$connString .= " user=$this->username";
		}
	    if ($this->password) {
			$connString .= " password=$this->password";
		}
		$connString .= " dbname=$this->databaseName";
			
		$this->_connectionID = @pg_Connect($connString);
		return $this->_connectionID;
	}

	// Returns: A positive link identifier on success, or
	// false on error.  Connect to the server with the 
	// provided arguments. The connection to the server will 
	// not be closed when the script terminates. Instead it 
	// will be kept for later future use
	function pconnect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$connString = "";
		$hostPieces = array();		
		/*	Must specify the database argument	*/
		if (!$argDatabaseName) {
			return false;
		}
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		$hostPieces = split(":", $this->hostname);
		if ($hostPieces[0]) {
			$connString .= "host=$hostPieces[0]";
			if (isset($hostPieces[1])) {
				$connString .= " port=$hostPieces[1]";
			}			
		}
	    if ($this->username) {
			$connString .= " user=$this->username";
		}
	    if ($this->password) {
			$connString .= " password=$this->password";
		}
		$connString .= " dbname=$this->databaseName";
			
		$this->_connectionID = @pg_pConnect($connString);
		if ($this->_connectionID) {
			$this->_isPersistentConnection = true;				
		}
		return $this->_connectionID;
	}		
	
	// Returns: true on success, false on error Select 
	// the database name to be used PostgreSQL 
	// Note:	function Not available
	function selectDB($dbName) {
			return false;
	}

	// Returns: the Recordset object disregard success 
	// or failure Send the sql statement to the database server
	function execute($sql = "") {
		// Instantiate an object without considering whether 
		// the query return any results or not
		$this->_queryID = @pg_Exec($this->_connectionID, $sql);
		$this->_tempResultObj = new Recordset($this->_queryID);
		$this->_insertQuery($this->_queryID);
		return $this->_tempResultObj;
	}
	
	// Returns: the last error message from previous 
	// database operation
	function errorMsg() {
		$this->_errorMsg = @pg_errormessage($this->_connectionID);
	    return $this->_errorMsg;
	}

	// Returns: true on success, false on failure 
	// Close the database connection
	function close() {
		if ($this->_queryIDList && sizeof($this->_queryIDList > 0)) {
			while(list($_key, $_resultID) = each($this->_queryIDList)) {
				@pg_freeresult($_resultID);
			}
		}
		// If its not a persistent connection, then 
		// only the connection needs to be closed
		if ($this->_isPersistentConnection != true) {	
			return @pg_close($this->_connectionID);
		}
		else {
			return true;
		}
	}
	
	// A PRIVATE function used by the constructor function 
	// of the query object.  insert the successful returned
	// query id to the query id list.  Used for later results 
	// cleanup.  A private function that's never meant to 
	// be used directly
	function _insertQuery($query_id) {
		$this->_queryIDList[] = $query_id;
	}		
}
	
//------------------------------
	 Class Name: Recordset
//------------------------------
class Recordset 
{
	/*	public variables	*/
	var $fields;
	// indicates that the current record position is before 
	// the first record in a Recordset object
	var $BOF = null;

	// indicates that the current record position is after
	// the last record in a Recordset object
	var $EOF = null;	
	
	/*	private variables	*/
	var $_numOfRows = -1; // NEVER change the value! READ-ONLY!
	var $_numOfFields = -1;	// NEVER change the value! READ-ONLY!
	// Holds anything that was returned from the database specific functions
	var $_tempResult = ''; 
	// This variable keeps the result link identifier
	var $_queryID = -1;	
	// This variable keeps the current row in the Recordset
	var $_currentRow = -1;

	// Returns: query id on success and false if 
	// failed Constructor function
	function Recordset($queryID) 
	{
		$this->_queryID = $queryID;
		if ($queryID) {
			$this->_numOfRows = @pg_numrows($this->_queryID);
			/*	pg_numrows() returns -1 on error	*/
			if ($this->_numOfRows == -1) {
				$this->_numOfRows = 0;
			}
			$this->_numOfFields = @pg_numfields($this->_queryID);
			/*	pg_numfields() returns -1 on error	*/
			if ($this->_numOfFields == -1) {
				$this->_numOfFields = 0;
			}
		}
		else {
			$this->_numOfRows = 0;
			$this->_numOfFields = 0;
		}
		/*	If result set contains rows	*/
		if ($this->_numOfRows > 0 && $this->_currentRow == -1) {
			$this->_currentRow = 0;
			$this->fields = @pg_fetch_array($this->_queryID, $this->_currentRow);			
			$this->EOF = false;
			$this->BOF = false;
		}
 		return $this->_queryID;
	}
		
	// Returns: true if successful, false if fail Set the Recordset 
	// pointer to a specified field offset. If the next call to 
	// fetchField() won't include a field offset, this field would 
	// be returned.  PostgreSQL Note:	function Not available
	function fieldSeek($fieldOffset = -1) {
		$this->_tempResult = false;
		return $this->_tempResult;
	}

	// Returns: an object containing field information.  Get column 
	// information in the Recordset object. fetchField() can be used 
	// in order to obtain information about fields in a certain query 
	// result. If the field offset isn't specified, the next field 
	// that wasn't yet retrieved by fetchField() is retrieved. 
	// PostgreSQL Note:	function Not available
	function fetchField($fieldOffset = -1) {
		$this->_tempResult = false;		
		return $this->_tempResult;
	}				

	// Returns: true if there still rows available, or false if there 
	// are no more rows.  Moves to the next row in a specified Recordset 
	// object and makes that record the current row and the data 
	// corresponding to the row will be retrieved into the fields 
	// collection.  Note: Unlike the moveRow() method, when _currentRow
	// is getNumOfRows() - 1, EOF will immediately be true.  If row number
	// is not provided, the function will point to the 
	// first row automatically
	function nextRow() {
		if ($this->getNumOfRows() > 0) {			
			$this->fields = array();
			$this->_currentRow++;
			$this->fields = @pg_fetch_array($this->_queryID, $this->_currentRow);
			/*	This is not working.  True all the time	*/
			if ($this->fields) {
				$this->_checkAndChangeEOF($this->_currentRow - 1);
				return true;
			}
		}
		$this->EOF = true;
		return false;
	}	
			
	// Returns: true on success, false on failure moveRow() moves 
	// the internal row pointer of the Recordset object to point 
	// to the specified row number and the data corresponding to
	// the row will be retrieved into the fields collection.  If 
	// row number is not provided, the function will point to 
	// the first row automatically
	function moveRow($rowNumber = 0) {
		if ($rowNumber == 0) {
			return $this->firstRow();
		}
		else if ($rowNumber == ($this->getNumOfRows() - 1)) {
			return $this->lastRow();
		}
		if ($this->getNumOfRows() > 0 && $rowNumber < $this->getNumOfRows()) {	
			$this->fields = null;
			$this->_currentRow = $rowNumber;
			$this->fields = @pg_fetch_array($this->_queryID, $this->_currentRow);
			/*	This is not working.  True all the time	*/
			if ($this->fields) {
				// No need to call _checkAndChangeEOF() because 
				// the possibility of moving to the last row 
				// has been handled by the above code
				$this->EOF = false;
				return true;
			}
		}
		$this->EOF = true;
		return false;
	}

	// Returns: true on success, false on failure firstRow() 
	// moves the internal row pointer of the Recordset object
	// to the first row and the data corresponding to the row 
	// will be retrieved into the fields collection
	function firstRow() {
		if ($this->getNumOfRows() > 0) {
			$this->fields = array();
			$this->_currentRow = 0;
			$this->fields = @pg_fetch_array($this->_queryID, $this->_currentRow);
			$this->EOF = true;
			/*	This is not working.  True all the time	*/
			if ($this->fields) {
				return true;	
			}
		}
		$this->EOF = true;
		return false;		
	}

	// Returns: true on success, false on failure lastRow() 
	// moves the internal row pointer of the Recordset object 
	// to the last row and the data corresponding to the row 
	// will be retrieved into the fields collection
	function lastRow() {
		if ($this->getNumOfRows() > 0) {	
			$this->fields = array();	
			$num_of_rows = $this->getNumOfRows();
			/*	$num_of_rows decemented at above 	*/
			$this->_currentRow = --$num_of_rows;	
			$this->fields = @pg_fetch_array($this->_queryID, $this->_currentRow);
			/*	This is not working.  True all the time	*/
			if ($this->fields) {
				/*	Special case for making EOF false.	*/
				$this->EOF = false;	
				return true;
			}
		}
		$this->EOF = true;
		return false;
	}

	// close() only needs to be called if you are worried about 
	// using too much memory while your script is running. All 
	// associated result memory for the specified result identifier 
	// will automatically be freed
	function close() {
		$this->_tempResult = @pg_freeresult($this->_queryID);		
		return $this->_tempResult;
	}

	// Returns: the number of rows in a result set.  
	// Get number of rows in result
	function getNumOfRows() {
		return $this->_numOfRows;
	}

	// Returns: the number of fields in a result set.
	// Get number of fields in result
	function getNumOfFields() {
		return $this->_numOfFields;
	}       

	/*	Check and change the status of EOF.	*/		
	function _checkAndChangeEOF($currentRow) {
		if ($currentRow >= ($this->_numOfRows - 1)) {
			$this->EOF = true;
		}		
		else {
			$this->EOF = false;		
		}
	}
}
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> Appendix G Microsoft SQL Server DB Wrapper Example <label id="mssql G">
<p>
Submitted by: Joe Thong
       <htmlurl url="mailto:
		   darkjoe@softhome.net
			" name="
		   darkjoe@softhome.net
		">
Site URL: <url url="http://phpdb.linuxbox.com">

<bf>Description: </bf> A PHP database wrapper for various database 
servers with a powerful
Recordset for result data manipulation.  Database results 
are flushed automatically by phpDB.

To get this file, in the web-browser, save this file as 'Text' type
as phpDB-mssql.lib
<code>
<?php
/*
Name: phpDB Microsoft SQL Server module
Version: 1.02bR6
Description: A PHP database wrapper for various 
	database servers with a powerful
	Recordset for result data manipulation.  Database 
	results are flushed automatically by phpDB.  
*/
// Define this module, to prevent double class declaration
if (!defined("_PHPDB_ABSTRACT_LAYER")) 
{
	define("_PHPDB_ABSTRACT_LAYER", 1 );
}
else
	return;

//------------------------------
	 Class Name: phpDB
//------------------------------
class phpDB 
{
	// public variables
	var $version = '1.02bR6'; // Version number of phpDB

	// This variable keeps what database type is going 
	// to be used.  Current supported database server 
	// are MySQL, MSQL, SQL Server, PostgreSQL and Sybase
	var $databaseType = ''; 
	var $databaseName = ''; // Specifies which database is going to be used

	// The hostname of the database server, port 
	// number is optional.  e.g: "db.devNation.com"
	var $hostname = ''; 

	var $username = ''; // to connect to the database server
	var $password = '';	// Password for the username
	
	// Private variables ----- starts with underscore

	// An array of executed querys. For results cleanup purposes
	var $_queryIDList = array();

	// The returned link identifier whenever a 
	// successful database connection is made
	var $_connectionID	= -1;
		
	// A variable which was used to keep the returned last 
	// error message.  The value will then returned 
	// by the errorMsg() function
	var $_errorMsg = ''; 
	// This variable keeps the last created result link identifier
	var $_queryID = -1;	

	// A boolean variable to state whether its a 
	// persistent connection or normal connection
	var	$_isPersistentConnection = false;	
	
	// Holds the newly created result object, returned 
	// via the execute() method
	var $_tempResultObj = '';	

	//	A constructor function for the phpDB object.  
	// When initializing, specify the dbType i.e: "mysql",
	// "msql", "postgresql", "mssql", and "sybase"
	function phpDB($dbType = "mssql") 
	{
		switch ($dbType) 
		{
			case "mysql":
			case "msql":
			case "postgresql":
			case "mssql":
			case "sybase":						
			case "informix":						
				$this->databaseType = $dbType;
				break;
			default:
				return false;
		}
	}

	// Returns: A positive link identifier on success, 
	// or false on error. 	Connect to the server with 
	// the provided arguments. The connection to the server 
	// will be closed when the script terminates, unless 
	// close() function is called beforehand.
	function connect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$boolDBSelected;
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		
		$this->_connectionID = @mssql_connect($this->hostname, $this->username, $this->password);
		
		if ($this->databaseName && $this->_connectionID) {
			$boolDBSelected = @mssql_select_db($this->databaseName);
			if(!$boolDBSelected) {	/*	If DB selection fails	*/
				@mssql_close($this->_connectionID);	/*	Close the current connection	*/
				return false;	
			}
		}		
		return $this->_connectionID;
	}

	// Returns: A positive link identifier on success, or 
	// false on error Connect to the server with the provided
	// arguments. The connection to the server will not be closed 
	// when the script terminates. Instead it will be kept for 
	// later future use
	function pconnect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$boolDBSelected;
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		
		$this->_connectionID = @mssql_pconnect($this->hostname, $this->username, $this->password);
		if ($this->_connectionID) {
			$this->_isPersistentConnection = true;				
		}
		
		if ($this->databaseName && $this->_connectionID) {
			$boolDBSelected = @mssql_select_db($this->databaseName);
			if(!$boolDBSelected) {	/*	if DB selection fails	*/
				return false;	/*	Persistent connection can't be closed	*/
			}
		}		
		return $this->_connectionID;
	}
	
	//	Returns: true on success, false on error Select the 
	// database name to be used
	function selectDB($dbName) 
	{
		$this->databaseName = $dbName;
		if ($this->_connectionID) {
			return @mssql_select_db($dbName);		
		}
		else {
			/*	No database selected	*/
			return false;
		}			
	}

	// Returns: the Recordset object disregard success or 
	// failure Send the sql statement to the database server
	function execute($sql = "") 
	{
		$this->_queryID = @mssql_query($sql, $this->_connectionID);
		// Instantiate an object without considering whether 
		// the query return any results or not
		$this->_tempResultObj = new Recordset($this->_queryID);
		$this->_insertQuery($this->_queryID);
		return $this->_tempResultObj;
	}

	// Returns: the last error message from previous database
	// operation Note: This function is NOT available for
	// Microsoft SQL Server
	function errorMsg() 
	{
		$this->_errorMsg = "errorMsg() is not available for Microsoft SQL Server";
	    return $this->_errorMsg;
	}

	/*	Returns: true on success, false on failure
		Close the database connection.	*/	
	function close() {
		if ($this->_queryIDList && sizeof($this->_queryIDList > 0)) {
			while(list($_key, $_resultID) = each($this->_queryIDList)) {
				@mssql_free_result($_resultID);
			}
		}
		// If its not a persistent connection, then 
		// only the connection needs to be closed
		if ($this->_isPersistentConnection != true) {	
			return @mssql_close($this->_connectionID);
		}
		else {
			return true;
		}
	}
	
	// A PRIVATE function used by the constructor function of 
	// the query object.  insert the successful returned 
	// query id to the query id list.  Used for later results
	// cleanup.  A private function that's never meant to be 
	// used directly
	function _insertQuery($query_id) {
		$this->_queryIDList[] = $query_id;
	}		
}

//---------------------------------------
	 Class Name: Recordset
//---------------------------------------
class Recordset 
{
	/*	public variables	*/
	var $fields;
	// indicates that the current record position is 
	// before the first record in a Recordset object
	var $BOF = null;
	// indicates that the current record position is 
	// after the last record in a Recordset object
	var $EOF = null;

	// Private variables
	var $_numOfRows = -1; // NEVER change the value!  READ-ONLY!
	var $_numOfFields = -1;	// NEVER change the value!  READ-ONLY!
	
	// Holds anything that was returned from the 
	// database specific functions
	var $_tempResult = '';	
	// This variable keeps the result link identifier
	var $_queryID = -1;	
	// This variable keeps the current row in the Recordset
	var $_currentRow = -1;

	// Returns: query id on success and false if 
	// failed Constructor function
	function Recordset($queryID) 
	{
		$this->_queryID = $queryID;
		if ($queryID) {
			$this->_numOfRows = @mssql_num_rows($this->_queryID);
			$this->_numOfFields = @mssql_num_fields($this->_queryID);
		}
		else {
			$this->_numOfRows = 0;
			$this->_numOfFields = 0;
		}
		// If result set contains rows	
		if ($this->_numOfRows > 0 && $this->_currentRow == -1) {
			$this->_currentRow = 0;
			$this->fields = @mssql_fetch_array($this->_queryID);
			$this->EOF = false;
			$this->BOF = false;
		}
 		return $this->_queryID;
	}
		
	// Returns: true if successful, false if fail Set 
	// the Recordset pointer to a specified field offset. 
	// If the next call to fetchField() won't include a 
	// field offset, this field would be returned
	function fieldSeek($fieldOffset = -1) {
		$this->_tempResult = @mssql_field_seek($this->_queryID, $fieldOffset);
		return $this->_tempResult;
	}

	// Returns: an object containing field information. 
	// Get column information in the Recordset object. 
	// fetchField() can be used in order to obtain information
	// about fields in a certain query result. If the field 
	// offset isn't specified, the next field that wasn't yet 
	// retrieved by fetchField() is retrieved
	function fetchField($fieldOffset = -1) {
		if ($fieldOffset != -1) {
			$this->_tempResult = @mssql_fetch_field($this->_queryID, $fieldOffset);
		}
		// The $fieldOffset argument is not provided thus its -1
		else if ($fieldOffset == -1) {	
			$this->_tempResult = @mssql_fetch_field($this->_queryID);
		}
		return $this->_tempResult;
	}

	// Returns: true if there still rows available, or false 
	// if there are no more rows.  Moves to the next row in a 
	// specified Recordset object and makes that record the current 
	// row and the data corresponding to the row will be retrieved
	// into the fields collection.  Note: Unlike the moveRow() method, 
	// when _currentRow is getNumOfRows() - 1, EOF will immediately be 
	// true.  If row number is not provided, the function will point 
	// to the first row automatically
	function nextRow() 
	{
		if ($this->getNumOfRows() > 0) {			
			$this->fields = array();
			$this->_currentRow++;
			$this->fields = @mssql_fetch_array($this->_queryID);
			// This is not working.  True all the time
			if ($this->fields) {	
				$this->_checkAndChangeEOF($this->_currentRow - 1);
				return true;
			}
		}
		$this->EOF = true;
		return false;
	}	
			
	// Returns: true on success, false on failure moveRow() 
	// moves the internal row pointer of the Recordset object 
	// to point to the specified row number and the data 
	// corresponding to the row will be retrieved into the fields 
	// collection.  If row number is not provided, the function will 
	// point to the first row automatically
	function moveRow($rowNumber = 0) 
	{
		if ($rowNumber == 0) {
			return $this->firstRow();
		}
		else if ($rowNumber == ($this->getNumOfRows() - 1)) {
			return $this->lastRow();
		}
		if ($this->getNumOfRows() > 0 && $rowNumber < $this->getNumOfRows()) {	
			$this->fields = null;
			$this->_currentRow = $rowNumber;
			if(@mssql_data_seek($this->_queryID, $this->_currentRow)) {
				$this->fields = @mssql_fetch_array($this->_queryID);
				/*	This is not working.  True all the time	*/
				if ($this->fields) {
					// No need to call _checkAndChangeEOF() because
					// the possibility of moving to the last row has 
					// been handled by the above code
					$this->EOF = false; 
					return true;
				}
			}
		}
		$this->EOF = true;
		return false;
	}

	// Returns: true on success, false on failure firstRow() moves
	// the internal row pointer of the Recordset object to the first 
	// row and the data corresponding to the row will be retrieved 
	// into the fields collection
	function firstRow() 
	{
		if ($this->getNumOfRows() > 0) {
			$this->fields = array();
			$this->_currentRow = 0;
			if (@mssql_data_seek($this->_queryID, $this->_currentRow)) {
				$this->fields = @mssql_fetch_array($this->_queryID);
				$this->EOF = false;
				/*	This is not working.  True all the time	*/
				if ($this->fields) {	
					return true;	
				}
			}
		}
		$this->EOF = true;
		return false;		
	}

	// Returns: true on success, false on failure lastRow() moves 
	// the internal row pointer of the Recordset object to the last
	// row and the data corresponding to the row will be retrieved 
	// into the fields collection
	function lastRow() 
	{
		if ($this->getNumOfRows() > 0) {	
			$this->fields = array();	
			$num_of_rows = $this->getNumOfRows();
			$this->_tempResult = @mssql_data_seek($this->_queryID, --$num_of_rows);
			if ($this->_tempResult) {
				/*	$num_of_rows decemented at above 	*/
				$this->_currentRow = $num_of_rows;
				$this->fields = @mssql_fetch_array($this->_queryID);
				/*	This is not working.  True all the time	*/
				if ($this->fields) {
					/*	Special case for making EOF false.	*/
					$this->EOF = false;	
					return true;
				}
			}
		}
		$this->EOF = true;
		return false;
	}

	// close() only needs to be called if you are worried about using
	// too much memory while your script is running. All associated 
	// result memory for the specified result identifier will 
	// automatically be freed
	function close() {
		$this->_tempResult = @mssql_free_result($this->_queryID);		
		return $this->_tempResult;
	}

	// Returns: the number of rows in a result set.  Get 
	// number of rows in result
	function getNumOfRows() {
		return $this->_numOfRows;
	}

	/*	Returns: the number of fields in a result set. 
	Get number of fields in result.	*/
	function getNumOfFields() {
		return $this->_numOfFields;
	}       

	/*	Check and change the status of EOF.	*/		
	function _checkAndChangeEOF($currentRow) {
		if ($currentRow >= ($this->_numOfRows - 1)) {
			$this->EOF = true;
		}		
		else {
			$this->EOF = false;		
		}
	}
}
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> Appendix H Sybase SQL Server DB Wrapper Example <label id="sybase H">
<p>
Submitted by: Joe Thong
       <htmlurl url="mailto:
		   darkjoe@softhome.net
			" name="
		   darkjoe@softhome.net
		">
Site URL: <url url="http://phpdb.linuxbox.com">

<bf>Description: </bf> A PHP database wrapper for various database 
servers with a powerful
Recordset for result data manipulation.  Database results 
are flushed automatically by phpDB.

To get this file, in the web-browser, save this file as 'Text' type
as phpDB-sybase.lib
<code>
<?php
/*
Name: phpDB Sybase module
Version: 1.02bR6
Description: A PHP database wrapper for various database 
	servers with a powerful Recordset for result data 
	manipulation.  Database results are flushed 
	automatically by phpDB.  
*/

// Define this module, to prevent double class declaration
if (!defined("_PHPDB_ABSTRACT_LAYER")) {
	define("_PHPDB_ABSTRACT_LAYER", 1 );
}
else
	return;

//-------------------------------
	 Class Name: phpDB
//-------------------------------
class phpDB 
{
	/*	public variables	*/
	var $version = '1.02bR6'; // Version number of phpDB
	// This variable keeps what database type is going 
	// to be used.  Current supported database server 
	// are MySQL, MSQL, SQL Server, and Sybase
	var $databaseType = ''; 
	// Specifies which database is going to be used
	var $databaseName = ''; 
	// The hostname of the database server, port number 
	// is optional.  e.g: "db.devNation.com"
	var $hostname = '';
	var $username = '';	// to connect to the database server
	var $password = ''; // Password for the username

	// Private variables --- starts with underscore
	// An array of executed querys.  For results 
	// cleanup purposes
	var $_queryIDList	= array();	
	// The returned link identifier whenever a successful 
	// database connection is made
	var $_connectionID	= -1;	
	// A variable which was used to keep the returned last 
	// error message.  The value will then returned by 
	// the errorMsg() function
	var $_errorMsg = '';
	// This variable keeps the last created result 
	// link identifier
	var $_queryID = -1;	
	// A boolean variable to state whether its a 
	// persistent connection or normal connection
	var	$_isPersistentConnection = false;	
	// Holds the newly created result object, returned 
	// via the execute() method
	var $_tempResultObj = '';

	// A constructor function for the phpDB object.  When 
	// initializing, specify the dbType i.e: "mysql", 
	// "msql", "postgresql", "mssql", and "sybase"
	function phpDB($dbType = "sybase") 
	{
		switch ($dbType) {
			case "mysql":
			case "msql":
			case "postgresql":
			case "mssql":
			case "sybase":						
			case "informix":						
				$this->databaseType = $dbType;
				break;
			default:
				return false;
		}			
	}
	
	// Returns: A positive link identifier on success, or
	// false on error. 	Connect to the server with the 
	// provided arguments. The connection to the server will be 
	// closed when the script terminates, unless close()
	// function is called beforehand
	function connect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$boolDBSelected;
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		
		$this->_connectionID = @sybase_connect($this->hostname, $this->username, $this->password);
		
		if ($this->databaseName && $this->_connectionID) {
			$boolDBSelected = @sybase_select_db($this->databaseName);
			/*	If DB selection fails	*/
			if(!$boolDBSelected) {	
				/*	Close the current connection	*/
				@sybase_close($this->_connectionID);
				return false;	
			}
		}		
		return $this->_connectionID;
	}

	// Returns: A positive link identifier on success, or false 
	// on error.  Connect to the server with the provided 
	// arguments. The connection to the server will not be closed
	// when the script terminates. Instead it will be kept for later future use
	function pconnect($argHostname = "", $argUsername = "", 
		$argPassword = "", $argDatabaseName = "") 
	{
		$boolDBSelected;
		if ($argHostname != "") {
			$this->hostname = $argHostname;
		}
		if ($argUsername != "") {
			$this->username = $argUsername;
		}
		if ($argPassword != "") {
			$this->password = $argPassword;
		}
		if ($argDatabaseName != "") {
			$this->databaseName = $argDatabaseName;
		}				
		
		$this->_connectionID = @sybase_pconnect($this->hostname, $this->username, $this->password);
		if ($this->_connectionID) {
			$this->_isPersistentConnection = true;				
		}
		
		if ($this->databaseName && $this->_connectionID) {
			$boolDBSelected = @sybase_select_db($this->databaseName);
			/*	if DB selection fails	*/
			if(!$boolDBSelected) {
				/*	Persistent connection can't be closed	*/
				return false;	
			}
		}		
		return $this->_connectionID;
	}
	
	/*	Returns: true on success, false on error 
		Select the database name to be used	*/
	function selectDB($dbName) {
		$this->databaseName = $dbName;
		if ($this->_connectionID) {
			return @sybase_select_db($dbName);		
		}
		else {
			/*	No database selected	*/
			return false;
		}			
	}

	/*	Returns: the Recordset object disregard success or failure
		Send the sql statement to the database server.	*/
	function execute($sql = "") {
		$this->_queryID = @sybase_query($sql, $this->_connectionID);
		// Instantiate an object without considering whether
		// the query return any results or not
		$this->_tempResultObj = new Recordset($this->_queryID);
		$this->_insertQuery($this->_queryID);
		return $this->_tempResultObj;
	}

	/*	Returns: the last error message from previous database operation
		Note: This function is NOT available for Sybase.	*/	

	function errorMsg() {
		$this->_errorMsg = "errorMsg() is not available for Sybase";
	    return $this->_errorMsg;
	}

	/*	Returns: true on success, false on failure
		Close the database connection.	*/	
		
	function close() {
		if ($this->_queryIDList && sizeof($this->_queryIDList > 0)) {
			while(list($_key, $_resultID) = each($this->_queryIDList)) {
				@sybase_free_result($_resultID);
			}
		}
		// If its not a persistent connection, then 
		// only the connection needs to be closed
		if ($this->_isPersistentConnection != true) {	
			return @sybase_close($this->_connectionID);
		}
		else {
			return true;
		}
	}
	
	// A PRIVATE function used by the constructor function
	// of the query object.  insert the successful returned 
	// query id to the query id list.  Used for later results 
	// cleanup.  A private function that's never meant 
	// to be used directly
	function _insertQuery($query_id) {
		$this->_queryIDList[] = $query_id;
	}		
}
	
//----------------------------------
	 Class Name: Recordset
//----------------------------------
class Recordset 
{
	/*	public variables	*/
	var $fields;
	// indicates that the current record position is 
	// before the first record in a Recordset object
	var $BOF = null;	
	// indicates that the current record position 
	// is after the last record in a Recordset object
	var $EOF = null;
	
	// Private variables - starts with underscore
	var $_numOfRows = -1; // NEVER change the value! READ-ONLY!
	var $_numOfFields = -1;	// NEVER change the value! READ-ONLY!
	// Holds anything that was returned from 
	// the database specific functions
	var $_tempResult = '';	
	// This variable keeps the result link identifier
	var $_queryID = -1;	
	// This variable keeps the current row in the Recordset
	var $_currentRow = -1;	

	// Returns: query id on success and false if 
	// failed Constructor function
	function Recordset($queryID) {
		$this->_queryID = $queryID;
		if ($queryID) {
			$this->_numOfRows = @sybase_num_rows($this->_queryID);
			$this->_numOfFields = @sybase_num_fields($this->_queryID);
		}
		else {
			$this->_numOfRows = 0;
			$this->_numOfFields = 0;
		}
		/*	If result set contains rows	*/
		if ($this->_numOfRows > 0 && $this->_currentRow == -1) {
			$this->_currentRow = 0;
			$this->fields = @sybase_fetch_array($this->_queryID);
			$this->EOF = false;
			$this->BOF = false;
		}
 		return $this->_queryID;
	}
		
	// Returns: true if successful, false if fail Set 
	// the Recordset pointer to a specified field offset. 
	// If the next call to fetchField() won't include a 
	// field offset, this field would be returned
	function fieldSeek($fieldOffset = -1) {
		$this->_tempResult = @sybase_field_seek($this->_queryID, $fieldOffset);
		return $this->_tempResult;
	}

	// Returns: an object containing field information.  
	// Get column information in the Recordset object. 
	// fetchField() can be used in order to obtain information
	// about fields in a certain query result. If the field 
	// offset isn't specified, the next field that wasn't yet
	// retrieved by fetchField() is retrieved
	function fetchField($fieldOffset = -1) {
		if ($fieldOffset != -1) {
			$this->_tempResult = @sybase_fetch_field($this->_queryID, $fieldOffset);
		}
		/*	The $fieldOffset argument is not provided thus its -1 	*/
		else if ($fieldOffset == -1) {	
			$this->_tempResult = @sybase_fetch_field($this->_queryID);
		}
		return $this->_tempResult;
	}

	// Returns: true if there still rows available, or 
	// false if there are no more rows.  Moves to the next
	// row in a specified Recordset object and makes that record 
	// the current row and the data corresponding to the row will
	// be retrieved into the fields collection.  Note: Unlike 
	// the moveRow() method, when _currentRow is getNumOfRows() - 1,
	// EOF will immediately be true.  If row number is not 
	// provided, the function will point to the 
	// first row automatically
	function nextRow() {
		if ($this->getNumOfRows() > 0) {			
			$this->fields = array();
			$this->_currentRow++;
			$this->fields = @sybase_fetch_array($this->_queryID);
			/*	This is not working.  True all the time	*/
			if ($this->fields) {
				$this->_checkAndChangeEOF($this->_currentRow - 1);
				return true;
			}
		}
		$this->EOF = true;
		return false;
	}	
			
	// Returns: true on success, false on failure moveRow()
	// moves the internal row pointer of the Recordset object 
	// to point to the specified row number and the data 
	// corresponding to the row will be retrieved into the
	// fields collection.  If row number is not provided, the
	// function will point to the first row automatically
	function moveRow($rowNumber = 0) {
		if ($rowNumber == 0) {
			return $this->firstRow();
		}
		else if ($rowNumber == ($this->getNumOfRows() - 1)) {
			return $this->lastRow();
		}
		if ($this->getNumOfRows() > 0 && $rowNumber < $this->getNumOfRows()) {	
			$this->fields = null;
			$this->_currentRow = $rowNumber;
			if(@sybase_data_seek($this->_queryID, $this->_currentRow)) {
				$this->fields = @sybase_fetch_array($this->_queryID);
				/*	This is not working.  True all the time	*/
				if ($this->fields) {	
					// No need to call _checkAndChangeEOF() 
					// because the possibility of moving to the 
					// last row has been handled by the above code
					$this->EOF = false; 
					return true;
				}
			}
		}
		$this->EOF = true;
		return false;
	}

	// Returns: true on success, false on failure firstRow()
	// moves the internal row pointer of the Recordset object
	// to the first row and the data corresponding to the row 
	// will be retrieved into the fields collection
	function firstRow() {
		if ($this->getNumOfRows() > 0) {
			$this->fields = array();
			$this->_currentRow = 0;
			if (@sybase_data_seek($this->_queryID, $this->_currentRow)) {
				$this->fields = @sybase_fetch_array($this->_queryID);
				$this->EOF = false;
				/*	This is not working.  True all the time	*/
				if ($this->fields) {
					return true;	
				}
			}
		}
		$this->EOF = true;
		return false;		
	}

	// Returns: true on success, false on failure lastRow() 
	// moves the internal row pointer of the Recordset object
	// to the last row and the data corresponding to the row
	// will be retrieved into the fields collection
	function lastRow() {
		if ($this->getNumOfRows() > 0) {	
			$this->fields = array();	
			$num_of_rows = $this->getNumOfRows();
			$this->_tempResult = @sybase_data_seek($this->_queryID, --$num_of_rows);
			if ($this->_tempResult) {
				/*	$num_of_rows decemented at above 	*/
				$this->_currentRow = $num_of_rows;
				$this->fields = @sybase_fetch_array($this->_queryID);
				/*	This is not working.  True all the time	*/
				if ($this->fields) {
					/*	Special case for making EOF false.	*/
					$this->EOF = false;
					return true;
				}
			}
		}
		$this->EOF = true;
		return false;
	}

	// close() only needs to be called if you are worried
	// about using too much memory while your script is 
	// running. All associated result memory for the 
	// specified result identifier will automatically be freed
	function close() {
		$this->_tempResult = @sybase_free_result($this->_queryID);		
		return $this->_tempResult;
	}

	/*	Returns: the number of rows in a result set. 
	Get number of rows in result.	*/
	
	function getNumOfRows() {
		return $this->_numOfRows;
	}

	/*	Returns: the number of fields in a result set. 
	Get number of fields in result.	*/
		
	function getNumOfFields() {
		return $this->_numOfFields;
	}       

	/*	Check and change the status of EOF.	*/		
	function _checkAndChangeEOF($currentRow) {
		if ($currentRow >= ($this->_numOfRows - 1)) {
			$this->EOF = true;
		}		
		else {
			$this->EOF = false;		
		}
	}
}
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> Appendix I phpDB.inc Example <label id="phpdb I">
<p>
Submitted by: Joe Thong
       <htmlurl url="mailto:
		   darkjoe@softhome.net
			" name="
		   darkjoe@softhome.net
		">
Site URL: <url url="http://phpdb.linuxbox.com">

<bf>Description: </bf> A PHP database wrapper for various database 
servers with a powerful
Recordset for result data manipulation.  Database results 
are flushed automatically by phpDB.

To get this file, in the web-browser, save this file as 'Text' type
as phpDB.inc
<code>
<?php
/*
Name: phpDB General module
Version: 1.02bR6
Description: A PHP database wrapper for various 
	database servers.  Database results are flushed 
	automatically by phpDB.  Supported database 
	servers are MySQL, MSQL, PostgreSQL, Microsoft 
	SQL Server and Sybase. 
*/

	if (!defined("_PHPDB_GENERAL_LAYER")) {
	  define("_PHPDB_GENERAL_LAYER", 1 );
	}
	else
		return;
	
	// Fill in the database server that you're
	// going to use.  Consult the phpDB Reference
	// Manual for more information
	$databaseType = '';
	// The phpDB module root path.  No trailing slash
	$phpDBRootPath = '.';	
	
	function useDB($dbType = "") 
	{
		GLOBAL $phpDBRootPath;
		switch (strtolower($dbType)) 
		{
			case "mysql":
			case "msql":
			case "postgresql":
			case "mssql":
			case "sybase":
			case "informix":
				include("$phpDBRootPath". "/phpDB-" . "$dbType.lib");
				break;
			case "":
				die("Please edit phpDB.inc in order to use phpDB");
				return false;
			default:
				die("Invalid database selection");
				return false;		
		}					
		return true;		
	}
	
	useDB($databaseType);
?>
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> Appendix J phpDBTest.php3 Example <label id="phpDBTest">
<p>
Submitted by: Joe Thong
       <htmlurl url="mailto:
		   darkjoe@softhome.net
			" name="
		   darkjoe@softhome.net
		">
Site URL: <url url="http://phpdb.linuxbox.com">

<bf>Description: </bf> A PHP database wrapper for various database 
servers with a powerful
Recordset for result data manipulation.  Database results 
are flushed automatically by phpDB.

To get this file, in the web-browser, save this file as 'Text' type
as phpDB-mssql.lib
<code>
<html>
< head>
	< title>Untitled< /title>
< /head>

< body>
<?php
	// Assumed this file is placed in the same directory with phpDB.inc
	include("phpDB.inc");	
	$db = new phpDB();
	$db->pconnect("hostName", "userName", "passWord", "databaseName") or die ("Can't connect to database server or select database");
	$rs = $db->execute("SELECT * FROM Items");
	$numOfRows = $rs->getNumOfRows();
	echo "Number of Rows: $numOfRows";	

	$rs->firstRow(); // optional, but recommended
	while (!$rs->EOF) {
		// Fields collection accessible as associative arrays too
		echo "<br>" . $rs->fields[0];
		$rs->nextRow();	// NOTE: nextRow() is placed at below
	}

	$rs->close();		
	$db->close();	// optional
?>
< /body>
< /html>
</code>
<!-- 
*******************************************
************ End of Section ***************
*******************************************




-->
</article>

<!--  LocalWords:  web-server get button the action.php page is called this you
 -->
<!--  LocalWords:  would have something like Surprise name and age variables by
 -->
<!--  LocalWords:  are automatically set for PHP IDE tools Many HTML editors of
 -->
<!--  LocalWords:  supporting Blue Fish Coffee cup Dreamweaver Amaya Homesite
 -->
<!--  LocalWords:  Hotdog Zend Optimizers Compilers near every XML will Rapid
 -->
<!--  LocalWords:  Application Development tool ctags Tags extremely valuable
 -->
<!--  LocalWords:  used navigation source inside emacs CRiSP NEdit If had lot
 -->
<!--  LocalWords:  programmed or Java might program tags see online manual type
 -->
<!--  LocalWords:  'man ctags' at linux bash prompt ptags given below which can
 -->
<!--  LocalWords:  use Your productivity improve times if also Vim text debug
 -->
<!--  LocalWords:  Debugging programs inc having following functions your put
 -->
<!--  LocalWords:  initial generally index.php line output values files calls
 -->
<!--  LocalWords:  as illustrated When run traced debug.out giving linenumber
 -->
<!--  LocalWords:  variable it's value generously usage NOT any impact on final
 -->
<!--  LocalWords:  production has because they filtered out described copy save
 -->
<!--  LocalWords:  time typing 'yank buffer' feature done development testing
 -->
<!--  LocalWords:  when ready deploy server filter from large group now WARNED
 -->
<!--  LocalWords:  deployment Limitations Everything limitations disadvantages
 -->
<!--  LocalWords:  exception Object Oriented
 -->
